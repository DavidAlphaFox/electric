STATUS : draft

# The electric protocol

## Purpose and goals

The electric protocol allows two processes called *peers*, typically running on two different physical machines (e.g.
a server and a client) on two different host plaforms (e.g. a JVM and a browser), to run an electric program and
synchronize their states in reaction to local events. The program being run is the only knowledge initially shared by
the two peers.

TODO: what is an electric program ? what is the entrypoint ? is it a zero-argument e/defn ?

The electric protocol allows for :
* maintaining the set of currently active transfer sessions, according to the active branches of the program
* multiplexing the successive changes for these transfer sessions, according to the state of each expression

An explicit goal of the protocol design is to allow for optimistic transfers, i.e. allow a given peer to anticipate
transfer of a local expression state when it's able to infer (from shared program knowledge) that a local event
requires a remote program section having this local expression as a dependency. This optimization helps reduce latency
by avoiding unnecessary round-trips.

As a consequence of this optimization, both peers can concurrently decide to start or stop a transfer session for the
same expression, and thus need to reach consensus about its lifecycle. This problem is exacerbated by the fact that
differential state propagation relies on sequential delivery - if one peer resets a session while the other one doesn't,
the latter will observe permanent state corruption.

TODO: example

## Channel

The protocol relies on a persistent connection, established beforehand, able to transport messages in both directions
with reliable delivery and ordering. The channel must support flow control in the writing direction, i.e. expose a
means to limit the rate of messages sent by a given peer when the underlying network layers can't keep up. Support for
flow control in the reading direction is not a requirement, because a peer is always able to accept new messages.

In the current implementation, websockets are used as the channel implementation. Alternative implementations could be
considered in the future.

TODO: is channel reconnection logic part of this document ?

## Serialization

The protocol assumes each expression being evaluated is identifiable by a serializable value called a *slot*, and the
differential states of any given expression are serializable.

TODO: is the expression identification scheme part of this document ?
TODO: is the serialization method is part of the protocol ? currently, transit is not an option

## Message structure
All messages are the serialization of a 4-tuple `[acks request change freeze]`, where :
* `acks` is a non-negative integer
* `request` is a map associating slots to non-zero integers
* `change` is a map associating slots to diffs
* `freeze` is a set of slots

The message structure is a natural monoid because all of its 4 components are monoids, as explained further.

### `acks` - Changeset acknowledgement
The `acks` number represents the count of non-*pure-ack* messages received by the sender since the previous message
was sent. A *pure-ack* is a message with an empty `request`, an empty `change`, and an empty `freeze`, i.e. a message
describing an empty changeset.

The *empty message* is a *pure-ack* with zero `acks`. The *empty message* has no effect and should not be sent. Any
other message MUST be sent as soon as the channel is ready to write.

The `acks` number is a monoid. The identity element is `0`, the binary operation is addition.

TODO: example

### `request` - Local request propagation
An electric program can reify the differential state of an expression as an effect. A peer with access to this effect
can decide to perform it, typically as part of an effect composition managed by another part of the same electric
program. For each remote expression that is a dependency of the local expression wrapped by this effect, the effect
lifecycle must be propagated via the `request` map by the association of the dependency slot with the number `1` (if
the process was spawned) or `-1` (if the process was terminated). The `request` map being sent on the wire is the
aggregation of all `request` maps generated by each local event since the last message was sent.

The `request` map is a monoid. The identity element is `{}`, the binary operation is map merging with value addition
and elision of zero values.

```clojure
(def merge-request
  (partial reduce-kv
    (fn [r k n]
      (let [n (+ n (r k 0))]
        (if (zero? n)
          (dissoc r k)
          (assoc r k n))))))
```

TODO: example

### `change` and `freeze` - Differential state propagation
The `request` map transfers, in combination with message `acks`, are used by both peers to reach consensus about the
transfer session lifecycle. When a given expression is part of the active session set, a half-port is instanciated on
each side of the channel - an output on the local peer, an input on the remote peer. The output is a subscription to
the expression's differential signal, the input is an object exposing the current state as a differential signal
according to incoming changes. The `change` map being sent on the wire is the aggregation of slot-diff pairs generated
by all local changes, the `freeze` set is the union of slots generated by local freezes (i.e. spontaneous termination
of the signal subscription), since the last message was sent.

The `change` map and `freeze` set form a monoid. The identity element is `{} #{}`, the binary operation is map merging
and set union. Diff sequences must be semigroups to resolve collisions on the change map (i.e. diff squashing).

TODO: example

## Session lifecycle consensus
The essence of the algorithm is to delay session teardown on local events, to give the remote peer a grace period. The
grace period is defined by the remote peer via message acknowledgement, therefore we know it's always long enough to
reach consensus but never longer than round-trip latency.

Let's consider the state of the half-port of a single expression on a given peer. The state machine is the same for
inputs and outputs, therefore it doesn't matter if the expression is local or remote.

The state of the half-port is defined by :
* the *remote request* flag : if some dependent local expression has a positive request count.
* the *local request* flag : if some dependent remote expression is required by a local effect.
* the *pending toggle* count : the messages sent but not yet acknowledged that will change the remote request flag on
the remote half-port.

Then we can derive the *inferred request* flag as the xor of the local request and the *pending toggle* odd parity.
This flag reflects the state of the local request before the oldest unacknowledged message was sent, i.e. the state
known to the remote peer when its messages are processed.

The half-port is considered idle when the *remote request* flag is disabled, the *inferred request* flag is disabled,
and the *pending toggle* count is zero. A new session starts on leaving the idle state and stops on entering it again.

TODO: example
