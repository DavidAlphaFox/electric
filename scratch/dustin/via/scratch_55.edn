
(require
  '[clojure.walk :refer [postwalk]]
  '[meander.epsilon :as m]
  '[meander.strategy.epsilon :as r]
  '[minitest :refer [tests]]
  '[fixplz.expr :refer [traverse-expr form?]])


(def ast                                                    ; :: Traversable
  '(println (+ (inc 1) (inc 2))))

;(def traverse postwalk)

(postwalk identity ast)
(postwalk #(doto % println) ast)

(def effects {'println (fn [& ars] (cp (apply println args)))
              'inc     inc
              '+       +})

(defn inject [x]
  (cond (form? x) (let [[f & args] x

                        mb (m/match x
                             (f ~a) (fmap f a)
                             (~f ~a ~b) (fapply f a b)
                             (f. ~a) (bind a f)
                             (f a) (apply f a))

                        f' (get effects f @(resolve f))
                        mb (apply f' args)]
                    mb)
    () x))

(postwalk inject ast)

; traverse :: (a -> m b) -> AST a -> m (AST b)


; data MyLang a = Println a | inc a | + a a
; data ClojureLang = ...

(defmacro via [ast])

(via (f ~a)) := '(fmap f a)
(via (~f ~a ~b)) := '(fapply f a b)
(via (f. ~a)) := '(bind a f)
(via (f a)) := '(f a)


(defn via2 [ast]
  (postwalk inject ast))

(via2 '(f ~a))





; sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
; sequence :: Map (Flow a) -> Flow (Map a)

; traverse :: (Traversable t, Applicative m) => (a -> m b) -> t a -> m (t b)
; traverse :: (a -> Flow b) -> Map a -> Flow (Map b)
